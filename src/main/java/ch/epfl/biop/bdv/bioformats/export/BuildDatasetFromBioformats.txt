package ch.epfl.biop.bdv.bioformats.export;

import bdv.export.ExportMipmapInfo;
import bdv.export.ProgressWriter;
import fiji.util.gui.GenericDialogPlus;
import ij.gui.GenericDialog;
import mpicbg.spim.data.generic.base.Entity;
import mpicbg.spim.data.generic.sequence.BasicViewDescription;
import mpicbg.spim.data.registration.ViewRegistrations;
import mpicbg.spim.data.sequence.*;
import mpicbg.spim.io.IOFunctions;
import net.imglib2.Dimensions;
import net.imglib2.util.Pair;
import net.imglib2.util.ValuePair;
import net.preibisch.mvrecon.fiji.datasetmanager.DatasetCreationUtils;
import net.preibisch.mvrecon.fiji.datasetmanager.FileListDatasetDefinition;
import net.preibisch.mvrecon.fiji.datasetmanager.FileListDatasetDefinitionUtil;
import net.preibisch.mvrecon.fiji.datasetmanager.FileListViewDetectionState;
import net.preibisch.mvrecon.fiji.datasetmanager.grid.RegularTranformHelpers;
import net.preibisch.mvrecon.fiji.datasetmanager.patterndetector.FilenamePatternDetector;
import net.preibisch.mvrecon.fiji.datasetmanager.patterndetector.NumericalFilenamePatternDetector;
import net.preibisch.mvrecon.fiji.plugin.Apply_Transformation;
import net.preibisch.mvrecon.fiji.plugin.resave.Generic_Resave_HDF5;
import net.preibisch.mvrecon.fiji.plugin.resave.ProgressWriterIJ;
import net.preibisch.mvrecon.fiji.plugin.resave.Resave_HDF5;
import net.preibisch.mvrecon.fiji.spimdata.SpimData2;
import net.preibisch.mvrecon.fiji.spimdata.boundingbox.BoundingBoxes;
import net.preibisch.mvrecon.fiji.spimdata.imgloaders.FileMapImgLoaderLOCI;
import net.preibisch.mvrecon.fiji.spimdata.imgloaders.LegacyFileMapImgLoaderLOCI;
import net.preibisch.mvrecon.fiji.spimdata.imgloaders.filemap2.FileMapGettable;
import net.preibisch.mvrecon.fiji.spimdata.imgloaders.filemap2.FileMapImgLoaderLOCI2;
import net.preibisch.mvrecon.fiji.spimdata.intensityadjust.IntensityAdjustments;
import net.preibisch.mvrecon.fiji.spimdata.interestpoints.ViewInterestPoints;
import net.preibisch.mvrecon.fiji.spimdata.pointspreadfunctions.PointSpreadFunctions;
import net.preibisch.mvrecon.fiji.spimdata.stitchingresults.StitchingResults;
import net.preibisch.mvrecon.process.interestpointregistration.pairwise.constellation.grouping.Group;

import java.awt.*;
import java.io.File;
import java.util.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.stream.Collectors;

import static net.preibisch.mvrecon.fiji.datasetmanager.FileListDatasetDefinition.*;

public class BuildDatasetFromBioformats {
/*
    public SpimData2 createDataset(List<File> files, String angleOrTileChoice, String channelOrIlluminationChoice )
    {

        FileListViewDetectionState state = new FileListViewDetectionState();
        FileListDatasetDefinitionUtil.detectViewsInFiles( files, state);

        Map<Class<? extends Entity>, List<Integer>> fileVariableToUse = new HashMap<>();
        List<String> choices = new ArrayList<>();

        FilenamePatternDetector patternDetector = new NumericalFilenamePatternDetector();
        patternDetector.detectPatterns( files );
        int numVariables = patternDetector.getNumVariables();

        StringBuilder inFileSummarySB = new StringBuilder();
        inFileSummarySB.append( "<html> <h2> Views detected in files </h2>" );

        // summary timepoints
        if (state.getMultiplicityMap().get( TimePoint.class ) == FileListDatasetDefinitionUtil.CheckResult.SINGLE)
        {
//			inFileSummarySB.append( "<p> No timepoints detected within files </p>" );
            choices.add( "TimePoints" );
        }
        else if (state.getMultiplicityMap().get( TimePoint.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED)
        {
            int numTPs = (Integer) state.getAccumulateMap( TimePoint.class ).keySet().stream().reduce(0, (x,y) -> Math.max( (Integer) x, (Integer) y) );
            inFileSummarySB.append( "<p style=\"color:green\">" + numTPs+ " timepoints detected within files </p>" );
            if (state.getAccumulateMap( TimePoint.class ).size() > 1)
                inFileSummarySB.append( "<p style=\"color:orange\">WARNING: Number of timepoints is not the same for all views </p>" );
        }

        inFileSummarySB.append( "<br />" );

        // we might want to know how many channels/illums or tiles/angles to expect even though we have no metadata
        // NB: dont use these results if there IS metadata
        final Pair< Integer, Integer > minMaxNumCannelsIndexed = FileListViewDetectionState.getMinMaxNumChannelsIndexed( state );
        final Pair< Integer, Integer > minMaxNumSeriesIndexed = FileListViewDetectionState.getMinMaxNumSeriesIndexed( state );

        // summary channel
        if (state.getMultiplicityMap().get( Channel.class ) == FileListDatasetDefinitionUtil.CheckResult.SINGLE)
        {
            inFileSummarySB.append( !state.getAmbiguousIllumChannel() ? "" : "<p>"+ getRangeRepresentation( minMaxNumCannelsIndexed ) + " Channels OR Illuminations detected within files </p>");
            choices.add( "Channels" );
        }
        else if (state.getMultiplicityMap().get( Channel.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED)
        {

            inFileSummarySB.append( "<p > " + getRangeRepresentation( minMaxNumCannelsIndexed ) + " Channels detected within files </p>" );
            inFileSummarySB.append( "<p style=\"color:orange\">WARNING: no metadata was found for Channels </p>" );
            if (state.getMultiplicityMap().get( Illumination.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED)
            {
                choices.add( "Channels" );
                inFileSummarySB.append( "<p style=\"color:orange\">WARNING: no matadata for Illuminations found either, cannot distinguish </p>" );
                inFileSummarySB.append( "<p style=\"color:orange\">WARNING: choose manually whether files contain Channels or Illuminations below </p>" );
            }
        } else if (state.getMultiplicityMap().get( Channel.class ) == FileListDatasetDefinitionUtil.CheckResult.MUlTIPLE_NAMED)
        {
            int numChannels = state.getAccumulateMap( Channel.class ).size();
            inFileSummarySB.append( "<p style=\"color:green\">" + numChannels + " Channels found within files </p>" );
        }

        //inFileSummarySB.append( "<br />" );

        // summary illum
        if ( state.getMultiplicityMap().get( Illumination.class ) == FileListDatasetDefinitionUtil.CheckResult.SINGLE )
        {
            //if (!state.getAmbiguousIllumChannel())
            //	inFileSummarySB.append( "<p> No illuminations detected within files </p>" );
            choices.add( "Illuminations" );
        }
        else if ( state.getMultiplicityMap().get( Illumination.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED )
        {
            if (state.getMultiplicityMap().get( Channel.class ).equals( FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED ))
                choices.add( "Illuminations" );
            else
                inFileSummarySB.append( "<p > " + getRangeRepresentation( minMaxNumCannelsIndexed ) + " Illuminations detected within files </p>" );
        }
        else if ( state.getMultiplicityMap().get( Illumination.class ) == FileListDatasetDefinitionUtil.CheckResult.MUlTIPLE_NAMED )
        {
            int numIllum = state.getAccumulateMap( Illumination.class ).size();
            inFileSummarySB.append( "<p style=\"color:green\">" + numIllum + " Illuminations found within files </p>" );
        }

        // summary tile
        if ( state.getMultiplicityMap().get( Tile.class ) == FileListDatasetDefinitionUtil.CheckResult.SINGLE )
        {
            //inFileSummarySB.append( "<p> No tiles detected within files </p>" );
            choices.add( "Tiles" );
        }
        else if ( state.getMultiplicityMap().get( Tile.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED )
        {
            inFileSummarySB.append( "<p > " + getRangeRepresentation( minMaxNumSeriesIndexed ) + " Tiles detected within files </p>" );
            inFileSummarySB.append( "<p style=\"color:orange\">WARNING: no metadata was found for Tiles </p>" );
            if (state.getMultiplicityMap().get( Angle.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED)
            {
                choices.add( "Tiles" );
                inFileSummarySB.append( "<p style=\"color:orange\">WARNING: no metadata for Angles found either, cannot distinguish </p>" );
                inFileSummarySB.append( "<p style=\"color:orange\">WARNING: choose manually wether files contain Tiles or Angles below </p>" );
            }
        }
        else if ( state.getMultiplicityMap().get( Tile.class ) == FileListDatasetDefinitionUtil.CheckResult.MUlTIPLE_NAMED )
        {
            int numTile = state.getAccumulateMap( Tile.class ).size();
            inFileSummarySB.append( "<p style=\"color:green\">" + numTile + " Tiles found within files </p>" );

        }

        //inFileSummarySB.append( "<br />" );

        // summary angle
        if ( state.getMultiplicityMap().get( Angle.class ) == FileListDatasetDefinitionUtil.CheckResult.SINGLE )
        {
            //inFileSummarySB.append( "<p> No angles detected within files </p>" );
            choices.add( "Angles" );
        }
        else if ( state.getMultiplicityMap().get( Angle.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED )
        {
            if (state.getMultiplicityMap().get( Tile.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED)
                choices.add( "Angles" );
            else
                inFileSummarySB.append( "<p > " + getRangeRepresentation( minMaxNumSeriesIndexed ) + " Angles detected within files </p>" );
        }
        else if ( state.getMultiplicityMap().get( Angle.class ) == FileListDatasetDefinitionUtil.CheckResult.MUlTIPLE_NAMED )
        {
            int numAngle = state.getAccumulateMap( Angle.class ).size();
            inFileSummarySB.append( "<p style=\"color:green\">" + numAngle + " Angles found within files </p>" );
        }

        inFileSummarySB.append( "</html>" );

        //GenericDialogPlus gd = new GenericDialogPlus("Define Metadata for Views");

        //gd.addMessage( "<html> <h1> View assignment </h1> </html> ");
        //addMessageAsJLabel( "<html> <h1> View assignment </h1> </html> ", gd);

        //gd.addMessage( inFileSummarySB.toString() );
        //addMessageAsJLabel(inFileSummarySB.toString(), gd);

        //String[] choicesAngleTile = new String[] {"Angles", "Tiles"};
        String[] choicesChannelIllum = new String[] {"Channels", "Illuminations"};

        //if (state.getAmbiguousAngleTile())
        String preferedAnglesOrTiles = state.getMultiplicityMap().get( Angle.class ) == FileListDatasetDefinitionUtil.CheckResult.MULTIPLE_INDEXED ? "Angles" : "Tiles";
        //if (state.getAmbiguousAngleTile() || state.getMultiplicityMap().get( Tile.class) == FileListDatasetDefinitionUtil.CheckResult.MUlTIPLE_NAMED)
        //    gd.addChoice( "BioFormats_Series_are?", choicesAngleTile, preferedAnglesOrTiles );

        preferedAnglesOrTiles = angleOrTileChoice;

        //if (state.getAmbiguousIllumChannel())
        //    gd.addChoice( "BioFormats_Channels_are?", choicesChannelIllum, choicesChannelIllum[0] );
        choicesChannelIllum[0] = channelOrIlluminationChoice;

        // We have grouped files -> detect patterns again, using only master files for group
        // that way, we automatically ignore patterns BioFormats has already grouped
        // e.g. MicroManager _MMSTack_Pos{?}.ome.tif -> positions are treated as series by BF
        // we have to keep the old pattern detector (for all files) -> it will be used for final view assignment
        FilenamePatternDetector patternDetectorOld = null;
        if (state.getGroupedFormat() )
        {
            patternDetectorOld = patternDetector;
            patternDetector = new NumericalFilenamePatternDetector();
            // detect in all unique master files in groupUsageMap := actual file -> (master file, series)
            patternDetector.detectPatterns( state.getGroupUsageMap().values().stream().map( p -> p.getA() ).collect( Collectors.toSet() ).stream().collect( Collectors.toList() ) );
            numVariables = patternDetector.getNumVariables();
        }

        if (numVariables >= 1)
//		sbfilePatterns.append( "<p> No numerical patterns found in filenames</p>" );
//		else
        {
            final Pair< String, String > prefixAndPattern = splitIntoPrefixAndPattern( patternDetector );
            final StringBuilder sbfilePatterns = new StringBuilder();
            sbfilePatterns.append(  "<html> <h2> Patterns in filenames </h2> " );
            sbfilePatterns.append( "<h3 style=\"color:green\"> " + numVariables + ""
                    + " numerical pattern" + ((numVariables > 1) ? "s": "") + " found in filenames</h3>" );
            sbfilePatterns.append( "</br><p> Patterns: " + getColoredHtmlFromPattern( prefixAndPattern.getB(), false ) + "</p>" );
            sbfilePatterns.append( "</html>" );
            //addMessageAsJLabel(sbfilePatterns.toString(), gd);
        }

        //gd.addMessage( sbfilePatterns.toString() );

        choices.add( "-- ignore this pattern --" );
        choices.add( Z_VARIABLE_CHOICE );
        String[] choicesAll = choices.toArray( new String[]{} );

        /* ----- Removed for simplification
        for (int i = 0; i < numVariables; i++)
        {
            gd.addChoice( "Pattern_" + i + " represents", choicesAll, choicesAll[0] );
            //do not fail just due to coloring
            try
            {
                ((Label) gd.getComponent( gd.getComponentCount() - 2 )).setForeground( getColorN( i ) );
            }
            catch (Exception e) {}
        }

        addMessageAsJLabel(  "<html> <h2> Voxel Size calibration </h2> </html> ", gd );
        ---/
         */
        final boolean allVoxelSizesTheSame = FileListViewDetectionState.allVoxelSizesTheSame( state );
        //Nif(!allVoxelSizesTheSame)
        //N    addMessageAsJLabel(  "<html> <p style=\"color:orange\">WARNING: Voxel Sizes are not the same for all views, modify them at your own risk! </p> </html> ", gd );

        final VoxelDimensions someCalib = state.getDimensionMap().values().iterator().next().getB();
        /*
        gd.addCheckbox( "Modify_voxel_size?", false );
        gd.addNumericField( "Voxel_size_X", someCalib.dimension( 0 ), 4 );
        gd.addNumericField( "Voxel_size_Y", someCalib.dimension( 1 ), 4 );
        gd.addNumericField( "Voxel_size_Z", someCalib.dimension( 2 ), 4 );
        gd.addStringField( "Voxel_size_unit", someCalib.unit() );
        */

        // try to guess if we need to move to grid
        // we suggest move if: we have no tile metadata
        //addMessageAsJLabel(  "<html> <h2> Move to Grid </h2> </html> ", gd );
        boolean haveTileLoc = state.getAccumulateMap( Tile.class ).keySet().stream().filter( t -> ((FileListDatasetDefinitionUtil.TileInfo)t).locationX != null && ((FileListDatasetDefinitionUtil.TileInfo)t).locationX != 0.0 ).findAny().isPresent();

        String[] choicesGridMove = new String[] {"Do not move Tiles to Grid (use Metadata if available)",
                "Move Tiles to Grid (interactive)", "Move Tile to Grid (Macro-scriptable)"};
        //Ngd.addChoice( "Move_Tiles_to_Grid_(per_Angle)?", choicesGridMove, choicesGridMove[!haveTileLoc ? 1 : 0] );

        //Ngd.showDialog();

        //Nif (gd.wasCanceled())
        //N    return null;

  //      boolean preferAnglesOverTiles = true;
  //      boolean preferChannelsOverIlluminations = true;
        //Nif (state.getAmbiguousAngleTile() || state.getMultiplicityMap().get( Tile.class) ==  FileListDatasetDefinitionUtil.CheckResult.MUlTIPLE_NAMED)
        //N    preferAnglesOverTiles = gd.getNextChoiceIndex() == 0;
        //Nif (state.getAmbiguousIllumChannel())
        //N    preferChannelsOverIlluminations = gd.getNextChoiceIndex() == 0;

//        fileVariableToUse.put( TimePoint.class, new ArrayList<>() );
//        fileVariableToUse.put( Channel.class, new ArrayList<>() );
//        fileVariableToUse.put( Illumination.class, new ArrayList<>() );
//        fileVariableToUse.put( Tile.class, new ArrayList<>() );
//        fileVariableToUse.put( Angle.class, new ArrayList<>() );

//        final List<Integer> zVariables = new ArrayList<>();
        /*for (int i = 0; i < numVariables; i++)
        {
            String choice = gd.getNextChoice();
            if (choice.equals( "TimePoints" ))
                fileVariableToUse.get( TimePoint.class ).add( i );
            else if (choice.equals( "Channels" ))
                fileVariableToUse.get( Channel.class ).add( i );
            else if (choice.equals( "Illuminations" ))
                fileVariableToUse.get( Illumination.class ).add( i );
            else if (choice.equals( "Tiles" ))
                fileVariableToUse.get( Tile.class ).add( i );
            else if (choice.equals( "Angles" ))
                fileVariableToUse.get( Angle.class ).add( i );
            else if (choice.equals( Z_VARIABLE_CHOICE ))
                zVariables.add( i );
        }*/

        // TODO handle Angle-Tile swap here
        FileListDatasetDefinitionUtil.resolveAmbiguity( state.getMultiplicityMap(), state.getAmbiguousIllumChannel(), preferChannelsOverIlluminations, state.getAmbiguousAngleTile(), !preferAnglesOverTiles );

        // if we have used a grouped pattern
        // we will still have to use the old pattern detector (containing all files) in the next step
        // update fileVariableToUse so all grouped patterns are ignored
        if (patternDetectorOld != null)
        {
            // ungrouped variables have more than one match in master files
            final boolean[] ungroupedVariable = new boolean[patternDetectorOld.getNumVariables()];
            final String[] variableInstances = new String[patternDetectorOld.getNumVariables()];
            for (final File masterFile : state.getGroupUsageMap().values().stream().map( p -> p.getA() ).collect( Collectors.toSet() ).stream().collect( Collectors.toList() ))
            {
                final Matcher m = patternDetectorOld.getPatternAsRegex().matcher( masterFile.getAbsolutePath() );
                m.matches();
                for (int i = 0; i<patternDetectorOld.getNumVariables(); i++)
                {
                    final String variableInstance = m.group( i + 1 );
                    if (variableInstances[i] == null)
                        variableInstances[i] = variableInstance;
                    // we found an instance != first
                    if (!variableInstances[i].equals( variableInstance ) )
                        ungroupedVariable[i] = true;
                }
            }

            // update fileVariablesToUse
            // idx of pattern in grouped files -> idx in all files
            for (final AtomicInteger oldIdx = new AtomicInteger(); oldIdx.get()<patternDetectorOld.getNumVariables(); oldIdx.incrementAndGet())
            {
                if (!ungroupedVariable[oldIdx.get()])
                    fileVariableToUse.forEach( (k, v) -> {
                        fileVariableToUse.put( k, v.stream().map( (idx) -> ((idx >= oldIdx.get()) ? idx + 1 : idx )).collect( Collectors.toList() ) );
                    });
            }
        }

        FileListDatasetDefinitionUtil.expandAccumulatedViewInfos(
                fileVariableToUse,
                patternDetectorOld == null ? patternDetector : patternDetectorOld,
                state);

        // here, we concatenate Z-grouped files
        if (zVariables.size() > 0)
            FileListDatasetDefinitionUtil.groupZPlanes( state, patternDetector, zVariables );

        // query modified calibration
        /* N final boolean modifyCalibration = gd.getNextBoolean();
        if (modifyCalibration)
        {
            final double calX = gd.getNextNumber();
            final double calY = gd.getNextNumber();
            final double calZ = gd.getNextNumber();
            final String calUnit = gd.getNextString();

            for (final Pair< File, Pair< Integer, Integer > > key : state.getDimensionMap().keySet())
            {
                final Pair<Dimensions, VoxelDimensions > pairOld = state.getDimensionMap().get( key );
                final Pair< Dimensions, VoxelDimensions > pairNew = new ValuePair< Dimensions, VoxelDimensions >( pairOld.getA(), new FinalVoxelDimensions( calUnit, calX, calY, calZ ) );
                state.getDimensionMap().put( key, pairNew );
            }
        }

        final int gridMoveType = gd.getNextChoiceIndex();*/

        // we create a virtual SpimData at first
        SpimData2 data = buildSpimData( state, true );

        // we move to grid, collect parameters first
        final List<RegularTranformHelpers.RegularTranslationParameters> gridParams = new ArrayList<>();

        //GenericDialogPlus gdSave = new GenericDialogPlus( "Save dataset definition" );

        //addMessageAsJLabel("<html> <h1> Loading options </h1> <br /> </html>", gdSave);
        //gdSave.addChoice( "how_to_load_images", loadChoices, loadChoices[0] );

        addMessageAsJLabel("<html><h2> Save path </h2></html>", gdSave);

        // get default save path := deepest parent directory of all files in dataset
        final Set<String> filenames = new HashSet<>();
        ((FileMapGettable)data.getSequenceDescription().getImgLoader() ).getFileMap().values().stream().forEach(
                p ->
                {
                    filenames.add( p.getA().getAbsolutePath());
                });
        final File prefixPath;
        if (filenames.size() > 1)
            prefixPath = getLongestPathPrefix( filenames );
        else
        {
            String fi = filenames.iterator().next();
            prefixPath = new File((String)fi.subSequence( 0, fi.lastIndexOf( File.separator )));
        }

        gdSave.addDirectoryField( "dataset_save_path", prefixPath.getAbsolutePath(), 55 );

        // check if all stack sizes are the same (in each file)
        boolean zSizeEqualInEveryFile = LegacyFileMapImgLoaderLOCI.isZSizeEqualInEveryFile( data, (FileMapGettable)data.getSequenceDescription().getImgLoader() );
        // only consider if there are actually multiple angles/tiles
        zSizeEqualInEveryFile = zSizeEqualInEveryFile && !(data.getSequenceDescription().getAllAnglesOrdered().size() == 1 && data.getSequenceDescription().getAllTilesOrdered().size() == 1);
        // notify user if all stacks are equally size (in every file)
        if (zSizeEqualInEveryFile)
        {
            addMessageAsJLabel( "<html><p style=\"color:orange\">WARNING: all stacks have the same size, this might be caused by a bug"
                    + " in BioFormats. </br> Please re-check stack sizes if necessary.</p></html>", gdSave );
            // default choice for size re-check: do it if all stacks are the same size
            gdSave.addCheckbox( "check_stack_sizes", zSizeEqualInEveryFile );
        }


        boolean multipleAngles = data.getSequenceDescription().getAllAnglesOrdered().size() > 1;
        if (multipleAngles)
            gdSave.addCheckbox( "apply_angle_rotation", true );

        gdSave.showDialog();

        if ( gdSave.wasCanceled() )
            return null;

        final int loadChoice = gdSave.getNextChoiceIndex();
        final boolean useVirtualLoader = loadChoice == 1;
        // re-build the SpimData if user explicitly doesn't want virtual loading
        if (!useVirtualLoader)
            data = buildSpimData( state, useVirtualLoader );

        File chosenPath = new File( gdSave.getNextString());
        data.setBasePath( chosenPath );

        // check and correct stack sizes (the "BioFormats bug")
        // TODO: remove once the bug is fixed upstream
        if (zSizeEqualInEveryFile)
        {
            final boolean checkSize = gdSave.getNextBoolean();
            if (checkSize)
            {
                IOFunctions.println( new Date( System.currentTimeMillis() ) + ": Checking file sizes ... " );
                LegacyFileMapImgLoaderLOCI.checkAndRemoveZeroVolume( data, (ImgLoader & FileMapGettable) data.getSequenceDescription().getImgLoader(), zVariables.size() > 0 );
                IOFunctions.println( new Date( System.currentTimeMillis() ) + ": Finished." );
            }
        }

        // now, we have a working SpimData and have corrected for unequal z sizes -> do grid move if necessary
        /*
        if (gridMoveType == 2)
        {
            final ArrayList<ViewDescription> vds = new ArrayList<>(data.getSequenceDescription().getViewDescriptions().values());

            final Set<Class<? extends Entity>> angleClassSet = new HashSet<>();
            angleClassSet.add( Angle.class );
            final Set<Class<? extends Entity>> tileClassSet = new HashSet<>();
            tileClassSet.add( Tile.class );

            // first, split by angles (we process each angle separately)
            final List< Group< ViewDescription > > vdsAngleGrouped = Group.splitBy( vds , angleClassSet );
            int i = 0;
            for (Group<ViewDescription> vdsAngle : vdsAngleGrouped)
            {
                // second, we split by tiles (all channels/illums/tps of a tile are grouped)
                final List< Group< ViewDescription > > tilesGrouped = Group.splitBy( new ArrayList<>( vdsAngle.getViews() ), tileClassSet );
                if (tilesGrouped.size() < 2)
                    continue;

                // sort by tile id of first view in groups
                Collections.sort( tilesGrouped, new Comparator< Group< ViewDescription > >()
                {
                    @Override
                    public int compare(Group< ViewDescription > o1, Group< ViewDescription > o2)
                    {
                        if (o1.size() == 0)
                            return -o2.size();
                        return o1.getViews().iterator().next().getViewSetup().getTile().getId() - o2.getViews().iterator().next().getViewSetup().getTile().getId();
                    }
                } );

                RegularTranformHelpers.RegularTranslationParameters gridParamsI = gridParams.get( i++ );
                RegularTranformHelpers.applyToSpimData( data, tilesGrouped, gridParamsI, true );
            }
        }
        */

        boolean applyAxis = false;
        if (multipleAngles)
            applyAxis = gdSave.getNextBoolean();

        // View Registrations should now be complete
        // with translated tiles, we also have to take the center of rotation into account
        if (applyAxis)
            Apply_Transformation.applyAxisGrouped( data );
        /*N
        boolean resaveAsHDF5 = loadChoice == 0;
        if (resaveAsHDF5)
        {
            final Map< Integer, ExportMipmapInfo> perSetupExportMipmapInfo = Resave_HDF5.proposeMipmaps( data.getSequenceDescription().getViewSetupsOrdered() );
            final int firstviewSetupId = data.getSequenceDescription().getViewSetupsOrdered().get( 0 ).getId();
            Generic_Resave_HDF5.lastExportPath = String.join( File.separator, chosenPath.getAbsolutePath(), "dataset");
            final Generic_Resave_HDF5.Parameters params = Generic_Resave_HDF5.getParameters( perSetupExportMipmapInfo.get( firstviewSetupId ), true, true );

            // HDF5 options dialog was cancelled
            if (params == null)
                return null;

            final ProgressWriter progressWriter = new ProgressWriterIJ();
            progressWriter.out().println( "starting export..." );

            Generic_Resave_HDF5.writeHDF5( data, params, progressWriter );

            System.out.println( "HDF5 resave finished." );

            net.preibisch.mvrecon.fiji.ImgLib2Temp.Pair< SpimData2, List< String > > result = Resave_HDF5.createXMLObject( data, new ArrayList<>(data.getSequenceDescription().getViewDescriptions().keySet()), params, progressWriter, true );

            // ensure progressbar is gone
            progressWriter.setProgress( 1.0 );

            data = result.getA();
        }*/
        /*N
        if (gridMoveType == 1)
        {
            data.gridMoveRequested = true;
        }
        */
       /* return data;

    }*/

/*

    private static SpimData2 buildSpimData( FileListViewDetectionState state, boolean withVirtualLoader )
    {

        //final Map< Integer, List< Pair< File, Pair< Integer, Integer > > > > fm = tileIdxMap;
        //fm.forEach( (k,v ) -> {System.out.println( k ); v.forEach( p -> {System.out.print(p.getA() + ""); System.out.print(p.getB().getA().toString() + " "); System.out.println(p.getB().getB().toString());} );});


        Map< Integer, List< Pair< File, Pair< Integer, Integer > > > > tpIdxMap = state.getIdMap().get( TimePoint.class );
        Map< Integer, List< Pair< File, Pair< Integer, Integer > > > > channelIdxMap = state.getIdMap().get( Channel.class );
        Map< Integer, List< Pair< File, Pair< Integer, Integer > > > > illumIdxMap = state.getIdMap().get( Illumination.class );
        Map< Integer, List< Pair< File, Pair< Integer, Integer > > > > tileIdxMap = state.getIdMap().get( Tile.class );
        Map< Integer, List< Pair< File, Pair< Integer, Integer > > > > angleIdxMap = state.getIdMap().get( Angle.class );


        List<Integer> timepointIndexList = new ArrayList<>(tpIdxMap.keySet());
        List<Integer> channelIndexList = new ArrayList<>(channelIdxMap.keySet());
        List<Integer> illuminationIndexList = new ArrayList<>(illumIdxMap.keySet());
        List<Integer> tileIndexList = new ArrayList<>(tileIdxMap.keySet());
        List<Integer> angleIndexList = new ArrayList<>(angleIdxMap.keySet());

        Collections.sort( timepointIndexList );
        Collections.sort( channelIndexList );
        Collections.sort( illuminationIndexList );
        Collections.sort( tileIndexList );
        Collections.sort( angleIndexList );

        int nTimepoints = timepointIndexList.size();
        int nChannels = channelIndexList.size();
        int nIlluminations = illuminationIndexList.size();
        int nTiles = tileIndexList.size();
        int nAngles = angleIndexList.size();

        List<ViewSetup> viewSetups = new ArrayList<>();
        List<ViewId> missingViewIds = new ArrayList<>();
        List<TimePoint> timePoints = new ArrayList<>();

        HashMap<Pair<Integer, Integer>, Pair<File, Pair<Integer, Integer>>> ViewIDfileMap = new HashMap<>();
        Integer viewSetupId = 0;
        for (Integer c = 0; c < nChannels; c++)
            for (Integer i = 0; i < nIlluminations; i++)
                for (Integer ti = 0; ti < nTiles; ti++)
                    for (Integer a = 0; a < nAngles; a++)
                    {
                        // remember if we already added a vs in the tp loop
                        boolean addedViewSetup = false;
                        for (Integer tp = 0; tp < nTimepoints; tp++)
                        {

                            List< Pair< File, Pair< Integer, Integer > > > viewList;
                            viewList = FileListDatasetDefinitionUtil.listIntersect( channelIdxMap.get( channelIndexList.get( c ) ), angleIdxMap.get( angleIndexList.get( a ) ) );
                            viewList = FileListDatasetDefinitionUtil.listIntersect( viewList, tileIdxMap.get( tileIndexList.get( ti ) ) );
                            viewList = FileListDatasetDefinitionUtil.listIntersect( viewList, illumIdxMap.get( illuminationIndexList.get( i ) ) );

                            // we only consider combinations of angle, illum, channel, tile that are in at least one timepoint
                            if (viewList.size() == 0)
                                continue;

                            viewList = FileListDatasetDefinitionUtil.listIntersect( viewList, tpIdxMap.get( timepointIndexList.get( tp ) ) );


                            Integer tpId = timepointIndexList.get( tp );
                            Integer channelId = channelIndexList.get( c );
                            Integer illuminationId = illuminationIndexList.get( i );
                            Integer angleId = angleIndexList.get( a );
                            Integer tileId = tileIndexList.get( ti );

                            System.out.println( "VS: " + viewSetupId );

                            if (viewList.size() < 1)
                            {
                                System.out.println( "Missing View: ch" + c +" a"+ a + " ti" + ti + " tp"+ tp + " i" + i );
                                int missingSetup = addedViewSetup ? viewSetupId - 1 : viewSetupId;
                                missingViewIds.add( new ViewId( tpId, missingSetup ) );

                            }
                            else if (viewList.size() > 1)
                                System.out.println( "Error: more than one View: ch" + c +" a"+ a + " ti" + ti + " tp"+ tp + " i" + i );
                            else
                            {
                                System.out.println( "Found View: ch" + c +" a"+ a + " ti" + ti + " tp"+ tp + " i" + i + " in file " + viewList.get( 0 ).getA().getAbsolutePath());

                                TimePoint tpI = new TimePoint( tpId );
                                if (!timePoints.contains( tpI ))
                                    timePoints.add( tpI );

                                if (!addedViewSetup)
                                    ViewIDfileMap.put( new ValuePair< Integer, Integer >( tpId, viewSetupId ), viewList.get( 0 ) );
                                else
                                    ViewIDfileMap.put( new ValuePair< Integer, Integer >( tpId, viewSetupId - 1 ), viewList.get( 0 ) );


                                // we have not visited this combination before
                                if (!addedViewSetup)
                                {
                                    Illumination illumI = new Illumination( illuminationId, illuminationId.toString() );

                                    Channel chI = new Channel( channelId, channelId.toString() );

                                    if (state.getDetailMap().get( Channel.class ) != null && state.getDetailMap().get( Channel.class ).containsKey( channelId))
                                    {
                                        FileListDatasetDefinitionUtil.ChannelInfo chInfoI = (FileListDatasetDefinitionUtil.ChannelInfo) state.getDetailMap().get( Channel.class ).get( channelId );
                                        if (chInfoI.wavelength != null)
                                            chI.setName( Integer.toString( (int)Math.round( chInfoI.wavelength )));
                                        if (chInfoI.fluorophore != null)
                                            chI.setName( chInfoI.fluorophore );
                                        if (chInfoI.name != null)
                                            chI.setName( chInfoI.name );
                                    }

                                    Angle aI = new Angle( angleId, angleId.toString() );

                                    if (state.getDetailMap().get( Angle.class ) != null && state.getDetailMap().get( Angle.class ).containsKey( angleId ))
                                    {
                                        FileListDatasetDefinitionUtil.AngleInfo aInfoI = (FileListDatasetDefinitionUtil.AngleInfo) state.getDetailMap().get( Angle.class ).get( angleId );

                                        if (aInfoI.angle != null && aInfoI.axis != null)
                                        {
                                            try
                                            {
                                                double[] axis = null;
                                                if ( aInfoI.axis == 0 )
                                                    axis = new double[]{ 1, 0, 0 };
                                                else if ( aInfoI.axis == 1 )
                                                    axis = new double[]{ 0, 1, 0 };
                                                else if ( aInfoI.axis == 2 )
                                                    axis = new double[]{ 0, 0, 1 };

                                                if ( axis != null && !Double.isNaN( aInfoI.angle ) &&  !Double.isInfinite( aInfoI.angle ) )
                                                    aI.setRotation( axis, aInfoI.angle );
                                            }
                                            catch ( Exception e ) {};
                                        }
                                    }

                                    Tile tI = new Tile( tileId, tileId.toString() );

                                    if (state.getDetailMap().get( Tile.class ) != null && state.getDetailMap().get( Tile.class ).containsKey( tileId ))
                                    {
                                        FileListDatasetDefinitionUtil.TileInfo tInfoI = (FileListDatasetDefinitionUtil.TileInfo) state.getDetailMap().get( Tile.class ).get( tileId );

                                        // check if we have at least one location != null
                                        // in the case that location in one dimension (e.g. z) is null, it is set to 0
                                        final boolean hasLocation = (tInfoI.locationX != null) || (tInfoI.locationY != null) || (tInfoI.locationZ != null);
                                        if (hasLocation)
                                            tI.setLocation( new double[] {
                                                    tInfoI.locationX != null ? tInfoI.locationX : 0,
                                                    tInfoI.locationY != null ? tInfoI.locationY : 0,
                                                    tInfoI.locationZ != null ? tInfoI.locationZ : 0} );
                                    }

                                    ViewSetup vs = new ViewSetup( viewSetupId,
                                            viewSetupId.toString(),
                                            state.getDimensionMap().get( (viewList.get( 0 ))).getA(),
                                            state.getDimensionMap().get( (viewList.get( 0 ))).getB(),
                                            tI, chI, aI, illumI );

                                    viewSetups.add( vs );
                                    viewSetupId++;
                                    addedViewSetup = true;

                                }

                            }
                        }
                    }

        SequenceDescription sd = new SequenceDescription( new TimePoints( timePoints ), viewSetups , null, new MissingViews( missingViewIds ));

        HashMap<BasicViewDescription< ? >, Pair<File, Pair<Integer, Integer>>> fileMap = new HashMap<>();
        for (Pair<Integer, Integer> k : ViewIDfileMap.keySet())
        {
            System.out.println( k.getA() + " " + k.getB() );
            ViewDescription vdI = sd.getViewDescription( k.getA(), k.getB() );
            System.out.println( vdI );
            if (vdI != null && vdI.isPresent()){
                fileMap.put( vdI, ViewIDfileMap.get( k ) );
            }
        }

        final ImgLoader imgLoader;
        if (withVirtualLoader)
            imgLoader = new FileMapImgLoaderLOCI2( fileMap, FileListDatasetDefinitionUtil.selectImgFactory(state.getDimensionMap()), sd, state.getWasZGrouped() );
        else
            imgLoader = new FileMapImgLoaderLOCI( fileMap, FileListDatasetDefinitionUtil.selectImgFactory(state.getDimensionMap()), sd, state.getWasZGrouped() );
        sd.setImgLoader( imgLoader );

        double minResolution = Double.MAX_VALUE;
        for ( VoxelDimensions d : state.getDimensionMap().values().stream().map( p -> p.getB() ).collect( Collectors.toList() ) )
        {
            for (int di = 0; di < d.numDimensions(); di++)
                minResolution = Math.min( minResolution, d.dimension( di ) );
        }

        // create calibration + translation view registrations
        ViewRegistrations vrs = DatasetCreationUtils.createViewRegistrations( sd.getViewDescriptions(), minResolution );

        // create the initial view interest point object
        final ViewInterestPoints viewInterestPoints = new ViewInterestPoints();
        viewInterestPoints.createViewInterestPoints( sd.getViewDescriptions() );

        SpimData2 data = new SpimData2( new File("/"), sd, vrs, viewInterestPoints, new BoundingBoxes(), new PointSpreadFunctions(), new StitchingResults(), new IntensityAdjustments() );
        return data;
    }
*/
}
